---
title: JS_high
date: 2024-10-19 10:40:20
tags:
---
# js高级

## 1.数据类型

### 1.1 分类
#### 1.1.1 基本类型

- 数值类型：Number
- 字符串类型：String
- 布尔类型：Boolean
- 空类型：Null
- 未定义类型：Undefined

#### 1.1.2 对象（引用）类型

- Object ：任意对象
- array ：（特别的对象，数值下标，内部有序）
- function ：函数（特别的对象，可以运行）

### 1.2 判断

- typeof：判断基本类型 返回数据类型的字符串表达
    - 可以判断 null / undefined / 数值 / 字符串 / 布尔值
- instanceof：判断对象类型
    - 可以判断数组、函数、对象
- ===：判断值和类型
    - 可以判断 udefine、null

### 1.3 类型剖析

#### 1.3.1 udefine和null的区别？
- undefined：变量声明但未赋值，值为undefined
- null：定义了，赋值了，变量值为null，表示空值

#### 1.3.2 什么时候给变量赋值为null？
- 1.初始赋值为null，一般表明将要赋值为对象
- 2.最后赋值为null，表示变量不再有意义，供垃圾回收器回收内存

#### 1.3.3 严格区别变量类型与数据类型？
- 数据类型：基本类型、对象类型
- 变量类型（变量内存值的类型）：
    - 基本类型：保存的就是基本类型的数据
    - 引用类型：保存的是地址值

## 2 数据、变量、内存

#### 2.1.1 什么是数据？
- 存储在内存中代表特定信息的“东西”，本质上是01字符串
- 数据的特点：
    - 可传递
    - 可运算
    - 可存储

#### 2.1.2 什么是内存？
- 内存条通电以后产生的可存储空间（临时的）
- 内存的产生与死亡：内存条（电路板）==>通电==>产生内存==>存储数据==>程序运行，处理数据==>断电==>内存空间和数据消失
- 内存分类：
    - 栈：全局变量/局部变量
    - 堆：对象

#### 2.1.3 什么是变量？
- 可变化的量，由变量名和变量值组成
- 每个变量都对应一块小内存，变量名用来查找对应内存，变量值存放在内存中

#### 2.2.1 内存、数据、变量三者的关系
- 内存是用来存储数据的空间
- 变量是内存的标识

#### 2.2.2 var a=xxx，a中到底保存了什么？
- xxx是基本数据，那么a中保存的就是基本数据的值
- xxx是对象，那么a中保存的就是引用数据在内存中的地址值
- xxx是一个变量，保存的xxx内存的内容（基本数据/地址值）

#### 2.2.3 关于引用变量赋值问题
- 2个引用变量指向同一个对象，修改其中一个变量，另一个变量也会跟着改变
- 2个引用变量指向不同的对象，修改其中一个变量，另一个变量不会跟着改变

#### 2.3.1 js在调用函数传递变量参数的时候，是值传递还是参数传递？
- 值（基本/地址值）传递

#### 2.3.2 js引擎如何管理内存？
- 内存生命周期
    - 分配小的内存空间，得到他的使用权
    - 存储数据，可以反复进行操作
    - 释放小内存空间

- 释放内存
    - 局部变量：函数执行完毕，变量内存空间自动释放
    - 对象：成为垃圾对象==>垃圾回收期回收


## 3.对象

#### 3.1.1 什么是对象？
- 多个对象的封装体
- 用来保存多个数据的容器
- 一个对象代表显示中的一个事物

#### 3.1.2 为什么要用对象？
- 统一管理多个数据

#### 3.1.3 对象的组成
- 属性：属性名（字符串）和属性值（任意类型）
- 方法：一种特殊的方法（属性值是一个函数）
#### 3.1.4 如何访问对象的内部数据？
- .属性名：访问对象的属性值，有时不能使用
- ["属性名"]：访问对象的属性值，任何情况通用
- 对象.方法名()：调用对象的某个方法

#### 3.2.1 什么时候必须使用["属性名"]访问属性？
- 属性名包含特殊字符
- 属性名是变量


## 4.函数

#### 4.1.1 什么是函数？
- 实现特定功能的n条语句的封装体
- 只有函数是可以执行的，其他类型都不能执行

#### 4.1.2 为什么要用函数？
- 提高代码的复用性
- 便于阅读交流

#### 4.1.3 如何定义函数？
- 函数声明
- 函数表达式

#### 4.1.4 如何调用（执行）函数？
- test（）：直接调用
- test.call（obj）：通过对象调用
- new test（）：new调用
- test.call/apply（obj）：相当于obj.test(),临时让test成为obj的方法，进行调用

## 5.回调函数

#### 5.1.1 什么函数才是回调函数？
- 编码者自己定义的函数
- 编码者自己没有调用
- 但是它（函数）最后执行

#### 5.1.2 常见的回调函数有哪些？
- dom事件回调函数
- 定时器回调函数
- ajax回调函数
- 生命周期回调函数

## 6.IIFE

#### 6.1.1 IIFE的理解？
- 全称： Immediately Invoked Function Expression（立即调用的函数表达式）
 
#### 6.1.2 IIFE的作用？
- 隐藏实现
- 不会污染全局命名空间
- 用来编写js模块化代码

## 7.函数中的this

#### 7.1.1 this是什么？
- 任何函数本质上都是通过某个对象调用的，未指定对象时，this就是window
- 所有函数内部都有一个this变量
- 它的值是调用函数的当前对象

#### 7.1.2 如何确定this的值？
- test（）：默认调用window
- test.call（obj）：obj调用
- new test()：新创建的对象
- p.test()：p调用

## 8.原型与原型链

#### 8.1.1 函数的property属性图
- 每个函数都有一个prototype属性，它默认指向一个object空对象（即称为：原型对象）
- 原型对象中有一个constructor属性，指向函数对象

#### 8.1.2 给原型对象添加属性（一般都是方法）
- 作用：函数的所有实例对象自动拥有原型中的属性（方法）

#### 8.2.1 显式原型与隐式原型
- 每个函数function都有一个内部属性prototype，即显示原型
- 每个实例对象都有一个__proto__属性，可称之为隐式原型
- 对象的隐式原型的值为其对应构造函数的显性原型的值
- 总结：
    - 函数的prototype属性：在定义函数时自动添加的，默认值是一个空对象
    - 实例对象的__proto__属性：在创建实例对象时自动添加的，默认值为构造函数的prototype属性值
    - 程序员能直接操作显示原型，但不能直接操作隐式原型（ES6之前）

#### 8.3.1 原型链
- 访问一个对象的属性时：
    - 先在自身属性中查找，找到并返回
    - 如果没有找到，再沿__proto__这条链上不断查找，找到并返回
    - 如果还没有找到，返回undifined
- 别名：隐式原型链
- 作用：查找对象的属性（方法）
- 补充：
    - 函数的显示原型指向的对象默认是空object实例对象（但是object不满足）
    - 所有函数都是Function的实例（包含Function）
    - Object的原型对象是原型链尽头

#### 8.3.2 原型链属性

- 读取对象的属性值：会自动到原型链上查找
- 设置对象的属性值：不会查找原型链，如果当前对象没有此属性，直接添加此属性并设置其值
- 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上

## 9.执行上下文与执行上下文栈

#### 9.1.1 变量提升与函数提升 
- 变量声明提升
    - 通过var定义的变量，在定义语句之前就可以被访问到
    - 值：undefined
- 函数声明提升
    - 通过function声明的函数，在之前就可以直接调用
    - 值：函数定义（对象）


#### 9.2.1 执行上下文
- 代码分类：
    - 全局代码
    - 函数（局部）代码
- 全局执行上下文
    - 在执行全局代码前将window确定为全局执行上下文
    - 对全局数据进行预处理
        - var定义的全局变量==>undefined，添加为window的属性
        - function定义的全局函数==>赋值（fun），添加为window的方法
        - this==>赋值（window）
    - 开始执行上下文
- 函数执行上下文
    - 在调用函数，准备执行函数体之前，创造对应的函数执行上下文对象
    - 对局部数据进行预处理
        - 形参变量==>赋值（实参）==>添加为执行上下文的属性
        - arguements（伪数组）==>赋值（实参列表），添加为执行上下文的属性
        - var定义的局部变量==>undefined，添加为执行上下文属性
        - function声明的函数==>赋值（fun），添加为执行上下文的方法
        - this==>赋值（调用函数的对象）
    - 开始执行函数体代码

#### 9.3.1 执行上下文栈
- 在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文对象
- 在全局执行上下文（window）确定后，将其添加到栈中（即压栈）
- 在函数执行上下文创建之后，将其添加到栈中
- 在当前函数执行完成后，将栈顶的对象移除栈（即出栈）
- 当所有的代码执行完成后，栈只剩下window对象

## 10.作用域与作用域链

#### 10.1.1 作用域的理解
- 就是一块“地盘”，一个代码段所在的区域
- 他是静态的（相对于上下文对象），在编写代码时就确定了

#### 10.1.2 作用域的分类
- 全局作用域
- 函数作用域
- 无块级作用域（ES6新增块作用域）

#### 10.1.3 作用域的作用
- 隔离变量，不同作用域下同名变量不会有冲突 

#### 10.2.1 作用域与执行上下文的区别1
- 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时
- 全局执行上下文环境数字哎全局作用域确定之后，JS代码马上执行之前创建
- 函数执行上下文环境是在调用函数时，函数体代码执行之前创建

#### 10.2.2 作用域与执行上下文的区别2
- 作用域是静态的，函数定义好了就一直存在，不再变化
- 上下文是动态的，函数调用时才创建，函数执行完毕后销毁

#### 10.2.3 作用域与执行上下文的联系
- 上下文环境（对象）是从属于所在的作用域
- 全局上下文环境==>全局作用域
- 函数上下文环境==>对应的函数作用域

## 11.闭包

#### 11.1.1 如何产生闭包？
- 当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量时，就产生了闭包

#### 11.1.2 闭包到底是什么？
- 使用chrome进行查看
- 理解一： 闭包是嵌套的内部函数（绝大部分人认为）
- 理解二： 包含被引用变量（函数）的对象（极少数人认为）
- 注意： 闭包存在于嵌套的内部函数之中

#### 11.1.3 产生闭包的条件
- 函数嵌套 
- 内部函数引用了外部函数的数据（变量/函数）

#### 11.2.1 常见的闭包
- 将函数作为另外一个函数的返回值
- 将函数作为实参残敌给另一个函数调用

#### 11.3.1 闭包的作用
- 使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）
- 让函数外部可以操作（读写）到函数内部的数据（变量/函数）

#### 11.3.2 函数执行完成后，函数声明的局部变量是否存在？
- 一般不存在，存在于闭包中的变量才可能存在

#### 11.3.3 （闭包）在函数外部能够直接访问函数内部的局部变量吗？
- 不能，但是我们可以通过闭包来让外部操作它

#### 11.4.1 闭包的生命周期
- 产生：在嵌套函数定义执行完成时就已经产生了（不是在调用时才产生）
- 死亡：在嵌套的函数内部函数成为垃圾对象时

#### 11.5.1 闭包的应用
- 定义JS模块：
    - 具有特定功能的JS文件
    - 将所有数据和功能都封装在一个函数内部（私有）
    - 只向外暴露一个包含n个方法的对象或函数
    - 模块的使用者，只需要通过模块暴露的对象调用方法来实现相应的功能

#### 11.6.1 闭包的缺点
- 缺点
    - 函数执行完成后，函数内的局部变量没有释放，占用内存的时间会变长
    - 容易造成内存泄露
- 解决方案
    - 能不用闭包就不用
    - 及时释放

## 12.对象

#### 12.1.1 对象构造模式
- Object构造函数模式：
    - 套路： 先创建空Object对象，再添加属性和方法
    - 适用场景： 起始时不确定对象内部数据
    - 问题： 语句太多
- 对象字面量模式：
    - 套路： 使用{}创建对象，提示指定属性和方法
    - 适用场景： 起始确定对象内部数据
    - 问题： 如果创建多个对象，代码重复
- 工厂模式：
    - 套路： 通过工厂函数（返回一个对象的函数）动态创建对象并返回
    - 适用场景： 需要创建多个对象
    - 问题： 没有一个具体的类型，都是Object类型
- 自定义构造函数模式：
    - 套路： 通过自定义构造函数，通过new创建对象
    - 适用场景： 需要创建多个类型确定的对象
    - 问题： 每个对象都有相同的数据，代码冗余
- 组合模式（构造函数+原型）：
    - 套路： 自定义构造函数，属性在函数中初始化，原型对象负责添加方法
    - 适用场景： 需要创建多个类型确定的对象

#### 12.2.1 原型链继承
- 套路：
    - 定义父类型构造函数
    - 给父类型的原型添加方法
    - 定义子类型构造函数
    - 子类型构造函数的原型指向父类型构造函数的实例
    - 将子类型的原型的构造属性设置为子类型
    - 给子类型原型添加方法
    - 创建子类型的对象
- 关键：
    - 子类型构造函数的原型指向父类型构造函数的实例

#### 12.2.2 借用构造函数继承
- 套路：
    - 定义父类型构造函数
    - 定义子类型构造函数
    - 在子类型构造函数中调用父类型构造函数
- 关键：
    - 子类型构造函数中通用super（）调用父类型构造函数

#### 12.2.3 组合继承
- 原型链+借用构造函数：
    - 利用原型链实现对父类型对象的方法继承
    - 利用super（）调用父类型构造函数初始化相同属性

