<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue2</title>
    <link href="/2024/10/26/Vue2/"/>
    <url>/2024/10/26/Vue2/</url>
    
    <content type="html"><![CDATA[<h2 id="VUE2"><a href="#VUE2" class="headerlink" title="VUE2"></a>VUE2</h2><h3 id="1-初识Vue"><a href="#1-初识Vue" class="headerlink" title="1.初识Vue"></a>1.初识Vue</h3><ul><li>想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象</li><li>root容器里面的代码一九符合html规范，只不过混入了一些特殊的Vue语法</li><li>root容器里的代码被称为【Vue模板】</li><li>Vue实例和容器是一一对应的</li><li>真实的开发中只有一个Vue实例，并且会配合着组件使用</li><li>中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性</li><li>一旦data中的数据发生变化，那么页面中用到该数据的地方也会自动更新</li></ul><hr><blockquote><p><code>注意区分：js表达式和js代码（语句）</code></p><blockquote><p><code>1.表达式：一个表达式会生成一个值，可以放在任何一个需要值的地方 </code></p><blockquote><p><code>(1). a </code><br><code>(2). b + 1 </code><br><code>(3). demo(1) </code><br><code>(4). x===y?&#39;a&#39;:&#39;b&#39; </code></p></blockquote><p><code>2.代码（语句）：</code></p><blockquote><p><code>(1). if(a&gt;b)</code><br><code>(2). for(let i=0;i&lt;10;i++)</code></p></blockquote></blockquote></blockquote><hr><h3 id="2-Vue模板"><a href="#2-Vue模板" class="headerlink" title="2.Vue模板"></a>2.Vue模板</h3><ul><li>插值语法：<ul><li>功能：用于解析标签体内容</li><li>写法：，xxx可以是任何js表达式，会自动读取到data中的所有属性</li></ul></li><li>指令语法：<ul><li>功能：用于解析标签（包括：标签属性，标签体内容，绑定事件….）</li><li>举例：v-bind：herf&#x3D;”xxx”  或简写为：  ：herf&#x3D;”xxx”</li><li>备注：Vue中有很多的指令，且形式都是：v-????，此处我们拿v-bind举例</li></ul></li></ul><h3 id="3-数据绑定"><a href="#3-数据绑定" class="headerlink" title="3.数据绑定"></a>3.数据绑定</h3><ul><li>v-bind:单向数据绑定</li><li>v-model:双向数据绑定，只能用在表单元素上（输入类元素）<ul><li>v-modle:value可以简写为v-model</li></ul></li></ul><h3 id="4-el与data的两种写法"><a href="#4-el与data的两种写法" class="headerlink" title="4.el与data的两种写法"></a>4.el与data的两种写法</h3><ul><li>el:<ul><li>创建Vue实例时，可以传入el参数，指定容器元素；</li><li>也可以创建v&#x3D;new Vue()，v.$mount(‘#root’)指定容器元素</li></ul></li><li>data:<ul><li>对象式</li><li>函数式，组件学习后，使用函数式</li></ul></li></ul><h3 id="5-MVVM模式"><a href="#5-MVVM模式" class="headerlink" title="5.MVVM模式"></a>5.MVVM模式</h3><ul><li>Model-View-ViewModel模式</li><li>Model：数据模型，即data中的数据</li><li>View：视图，即页面显示的部分，由HTML模板和指令组成</li><li>ViewModel：视图模型，即Vue实例，负责处理数据和视图间的交互</li><li>data中所有的属性，最后都出现在vm上A</li><li>vm身上的所有属性 及 Vue原型上的所有属性，在Vue模板中都可以直接使用</li></ul><h3 id="6-Object-defineProperty"><a href="#6-Object-defineProperty" class="headerlink" title="6.Object.defineProperty()"></a>6.Object.defineProperty()</h3><ul><li><img src="/2024/10/26/Vue2/Vue2-6.1.png" alt="数据代理"></li></ul><h3 id="7-数据代理"><a href="#7-数据代理" class="headerlink" title="7.数据代理"></a>7.数据代理</h3><ul><li>通过一个对象对另一个对象中属性的操作</li></ul><h3 id="8-Vue中的数据代理"><a href="#8-Vue中的数据代理" class="headerlink" title="8.Vue中的数据代理"></a>8.Vue中的数据代理</h3><ul><li>通过vm对象来代理data对象中属性的操作（读&#x2F;写）</li><li>好处：更加方便的操作data中的数据</li><li>原理：<ul><li>通过Object.defineProperty()方法把data对象中所有属性添加到vm上，为每一个添加到vm上的属性，都指定一个getter和setter方法，当vm上属性被访问或修改时，会自动调用getters和setters方法，从而实现双向数据绑定</li></ul></li></ul><h3 id="9-事件处理"><a href="#9-事件处理" class="headerlink" title="9.事件处理"></a>9.事件处理</h3><ul><li>使用v-on指令绑定事件，或者@xxx绑定事件（其中xxx是事件名）</li><li>事件的回调需要配置在methods中</li><li>methods中配置函数时，不要使用箭头函数</li><li>函数中this指向vm实例</li><li>@click&#x3D;”demo”与@click&#x3D;”demo($event)”一致，但是后者可以传参</li></ul><h3 id="10-事件修饰符"><a href="#10-事件修饰符" class="headerlink" title="10.事件修饰符"></a>10.事件修饰符</h3><ul><li>.stop：阻止事件冒泡</li><li>.prevent：阻止默认事件</li><li>.once：只执行一次</li><li>.capture：使用事件捕获模式</li><li>.self：只有event.target是当前操作元素时，才触发事件</li><li>.passive：事件的默认行为立即执行，不会等待事件回调函数执行完毕</li><li>修饰符可以链式使用</li><li><img src="/images/Vue2-10.1.png" alt="事件修饰符1"></li><li><img src="/images/Vue2-10.2.png" alt="事件修饰符2"></li></ul><h3 id="11-键盘事件"><a href="#11-键盘事件" class="headerlink" title="11.键盘事件"></a>11.键盘事件</h3><ul><li>常用按键别名：<ul><li>回车 &#x3D;&#x3D;&gt; enter</li><li>删除 &#x3D;&#x3D;&gt; delete(退格&#x2F;delete)</li><li>退出 &#x3D;&#x3D;&gt; esc</li><li>空格 &#x3D;&#x3D;&gt; space</li><li>换行 &#x3D;&#x3D;&gt; tab(特殊，配合keydown)</li><li>上 &#x3D;&#x3D;&gt; up</li><li>下 &#x3D;&#x3D;&gt; down</li><li>左 &#x3D;&#x3D;&gt; left</li><li>右 &#x3D;&#x3D;&gt; right</li></ul></li><li>Vue中未提供别名的案件，可以用原始key值去绑定</li><li>系统修饰键（用法特殊）：ctrl &#x2F; alt &#x2F; shift &#x2F;meta(win健)<ul><li>配合keyup：按下后，同时按住其余按键，松开其他按键</li><li>配合keydown：正常触发事件</li></ul></li><li>利用keyCode绑定事件（不推荐）</li><li>自己定义别名  Vue.config.keyCodes.xxx &#x3D; yyy（xxx为自定义按键名，yyy为原始按键值）<br><code>键盘事件也可以链式使用（不常见）</code></li></ul><h3 id="12-计算属性"><a href="#12-计算属性" class="headerlink" title="12.计算属性"></a>12.计算属性</h3><ul><li>计算属性是一种特殊的属性，它依赖于已有的属性，并返回一个值</li><li>语法：computed:{属性名：函数}</li><li>计算属性的函数中，this指向vm实例</li><li>计算属性的返回值会被缓存，只有当依赖的数据发生变化时，才会重新计算</li><li>计算属性的返回值可以直接用在模板中，也可以用在其他地方</li></ul><h3 id="13-监视属性"><a href="#13-监视属性" class="headerlink" title="13.监视属性"></a>13.监视属性</h3><ul><li>监视属性是一种特殊的属性，它依赖于已有的属性，并在属性值发生变化时，执行一个函数</li><li>监视属性必须存在</li><li>两种写法：<ul><li>1.watch:{属性名：函数}</li><li>2.vm.$watch(‘属性名’,函数)</li></ul></li><li>深度监视：deep:true,监视多级结构中所有属性的变化，watch默认不检测多级结构内部的变化</li><li>immediate:true 初始化时，会执行一次回调函数</li></ul><h3 id="14-computed和watch的区别"><a href="#14-computed和watch的区别" class="headerlink" title="14.computed和watch的区别"></a>14.computed和watch的区别</h3><ul><li>区别：<ul><li>1.computed能够完成的功能，watch都可以做到</li><li>2.watch可以做到的功能，computed不一定能完成，例如watch可以进行异步操作</li></ul></li><li>两个重要小原则：<ul><li>1.所有被Vue管理的函数，最好使用普通函数，这样this才是指向vm实例或者组件实例</li><li>2.所有不被Vue所管理的函数（定时器回调函数，ajax回调函数），最好写成箭头函数，这样this的指向才会是vm或者实例组件</li></ul></li></ul><h3 id="15-绑定class样式"><a href="#15-绑定class样式" class="headerlink" title="15.绑定class样式"></a>15.绑定class样式</h3><ul><li>字符串形式&lt; ：class&#x3D;”xxx”&gt; 适用于样式名不确定，需要动态指定</li><li>数组写法：&lt;:class&#x3D;”[xxx,yyy]”&gt; 适用于样式名不确定，名字也不确定</li><li>对象写法：&lt;:class&#x3D;”{xxx:true,yyy:false}”&gt; 适用于样式名确定，名字也确定，但要动态决定状态</li></ul><h3 id="16-style绑定"><a href="#16-style绑定" class="headerlink" title="16.style绑定"></a>16.style绑定</h3><ul><li>对象写法：style&#x3D;”{color:red,fontSize:16px}”</li><li>数组写法：style&#x3D;”[style1,style2]”</li></ul><h3 id="17-条件渲染"><a href="#17-条件渲染" class="headerlink" title="17.条件渲染"></a>17.条件渲染</h3><ul><li>v-show：根据条件，决定是否渲染标签</li><li>v-if：根据条件，决定是否渲染标签及其子元素</li><li>v-else-if：等价于python中的elif</li><li>v-else：等价于python中的else</li><li>后面三者不能分割使用</li></ul><h3 id="18-列表渲染"><a href="#18-列表渲染" class="headerlink" title="18.列表渲染"></a>18.列表渲染</h3><ul><li>v-for：<ul><li>1.用于展示列表数据</li><li>2.语法：v-for&#x3D;”(item,index) in item :key&#x3D;index”</li><li>可遍历对象： 数组、对象、字符串、指定次数（后两者用的很少）</li></ul></li><li>key的原理：<ul><li>key是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据新数据生成新的虚拟DOM，随后将新旧DOM 进行比较，找出需要更新的部分，然后进行局部更新</li><li>开发中最好使用每条数据的唯一标识作为key，如果不存在逆序添加则用index作为key也没有问题</li></ul></li><li>列表过滤:<ul><li>filter()实现 </li><li>watch实现：</li><li><img src="/images/Vue2-18.1.png" alt="列表过滤1"></li><li>computed实现：</li><li><img src="/images/Vue2-18.2.png" alt="列表过滤2"></li></ul></li><li>列表排序：<ul><li>sort(val1，val2 )实现<ul><li>val1-val2 升序</li><li>val2-val1 降序</li></ul></li></ul></li></ul><h3 id="19-vue-set"><a href="#19-vue-set" class="headerlink" title="19.vue.set()"></a>19.vue.set()</h3><ul><li>作用：动态添加属性到data中</li><li>语法：Vue.set(对象，’属性名’,值)</li><li>注意：<ul><li>1.对象必须是data中的对象</li><li>2.属性名必须是字符串</li><li>3.值可以是任意类型<br><code>局限：只能给vm._data中的对象实行动态添加，不能直接给vm._data添加属性</code></li></ul></li></ul><h3 id="20-vm-set"><a href="#20-vm-set" class="headerlink" title="20.vm.$set()"></a>20.vm.$set()</h3><ul><li>作用：动态添加属性到data中</li><li>语法：vm.$set(对象，’属性名’,值)</li><li>注意：<ul><li>1.对象可以是data中的对象，也可以是vm实例</li><li>2.属性名必须是字符串</li><li>3.值可以是任意类型<br><code>局限：只能给vm._data中的对象实行动态添加，不能直接给vm._data添加属性</code></li></ul></li></ul><h3 id="21-Vue检测数据的原理"><a href="#21-Vue检测数据的原理" class="headerlink" title="21.Vue检测数据的原理"></a>21.Vue检测数据的原理</h3><ul><li>Vue会监视data中所有层次的数据</li><li>如何实现监测对象中的数据:<ul><li>通过setter实现监视，且要在new Vue()时，就传入要监测的数据<ul><li>（1）对象中后追加的属性，Vue默认不做响应式处理</li><li>（2）如果需要给后面添加的属性做响应式，需要使用Vue.set()或者vm.$set()方法</li></ul></li></ul></li><li>如何实现监测数组中的数据：<ul><li>通过包裹数组更新元素的方法实现，本质就是做了两件事<ul><li>（1）调用原生对应的方法对数组进行更新</li><li>（2）重新解析模板，进而更新页面</li></ul></li></ul></li><li>在Vue修改数组中的某个元素一定要用如下方法：<ul><li>使用这些API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()</li><li>Vue.set()、vm.$set()</li></ul></li></ul><p><code>特别注意：Vue.set()、vm.$set()只能给data中的对象添加属性，不能给vm或者vm的根数据添加属性</code></p><h3 id="22-表单收集"><a href="#22-表单收集" class="headerlink" title="22.表单收集"></a>22.表单收集</h3><ul><li>若<code>&lt;input type=&quot;text&quot;&gt;</code>，则v-model收集的是value值，用户输入的也是value值</li><li>若<code>&lt;input type=&quot;radio&quot;&gt;</code>，则v-model收集的是value值，要给标签配置value值，用户选择哪个，v-model会更新为相应的value值</li><li>若<code>&lt;input type=&quot;checkbox&quot;&gt;</code><ul><li>没有配置value值，则v-model收集的是布尔值，用户勾选，v-model会更新为true</li><li>配置了value值，且初始值为数组，那么收集的就是由value组成的数组</li><li>配置了value值，且初始值为非数组，那么收集的就是布尔值</li></ul></li><li>v-modle的修饰符：<ul><li>.lazy：默认情况下，v-model在每次input事件触发时，都会更新数据，加上.lazy修饰符，则只在输入框失去焦点时，才会更新数据</li><li>.number：将用户输入的字符串转换为数字类型</li><li>.trim：自动去除用户输入的首尾空格</li></ul></li></ul><h3 id="23-过滤器"><a href="#23-过滤器" class="headerlink" title="23.过滤器"></a>23.过滤器</h3><ul><li><p>定义：对要显示的数据进行特定格式化之后再显示（适用于一些简单逻辑）</p></li><li><p>语法：<br><code>    - 注册过滤器：Vue.filter(&#39;过滤器名&#39;,函数)</code><br><code>    - 使用过滤器：&#123;&#123;xxx|yyy&#125;&#125;(yyy为过滤器名)</code></p></li><li><p>备注：</p><ul><li>1.过滤器可以链式使用</li><li>2.未改变原本的元素</li></ul></li></ul><h3 id="24-内置指令"><a href="#24-内置指令" class="headerlink" title="24.内置指令"></a>24.内置指令</h3><ul><li>v-bind:单向数据绑定，简写— ：xxx</li><li>v-model:双向数据绑定</li><li>v-for: 遍历数组对象字符串</li><li>v-on : 绑定事件监听，简写—- @xxx</li><li>v-if: 条件渲染</li><li>v-else: 条件渲染</li><li>v-show: 条件渲染，与v-if的区别是，v-show会始终渲染标签，只是改变display:none&#x2F;block</li><li>v-text: 显示文本内容，与插值语法的区别是，v-text不会解析表达式，直接显示文本内容,不可以进行文本拼接</li><li>v-html:支持结构解析，可以解析html代码，不建议使用</li><li>v-cloak: 解决闪烁问题，在页面加载时，隐藏标签（配合css），等Vue实例创建完成，再显示标签（无需赋值）</li><li>v-once：只渲染一次，数据变化时，不会重新渲染（无需赋值）</li><li>v-pre：跳过当前元素和子元素的编译过程，直到遇到v-cloak指令才开始编译</li></ul><h3 id="25-自定义指令"><a href="#25-自定义指令" class="headerlink" title="25.自定义指令"></a>25.自定义指令</h3><ul><li>定义：自定义指令，可以绑定到元素上，实现一些特殊功能</li><li>语法：<ul><li>注册指令：Vue.directive()或者derectives</li><li>函数式：Vue.directive(‘指令名’:function(el,binding,vnode){})</li><li>对象式：Vue.directive(‘指令名’:{<br>  bind:function(el,binding,vnode){},—一开始就执行<br>  update:function(el,binding,vnode){},—数据更新时执行<br>  inserted:function(el,binding,vnode){},—插入DOM时执行<br>  })</li></ul></li><li>备注：<ul><li>定义时不加v，使用时要加v</li><li>指令名是多个单词，那么需要用-连接</li></ul></li></ul><h3 id="26-生命周期"><a href="#26-生命周期" class="headerlink" title="26.生命周期"></a>26.生命周期</h3><ul><li>又名生命周期函数、生命周期钩子，名字不可更改，this指向vm</li><li>四对生命周期函数：<ul><li>beforeCreate：实例刚被创建，数据观测和事件配置还未开始</li><li>created：实例创建完成，数据观测和事件配置已完成，但还没有挂载到实例上，$el还不存在</li><li>beforeMount：实例开始挂载，$el已存在，但还没有开始渲染</li><li>mounted：实例挂载完成，$el已渲染完成</li><li>beforeUpdate：数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前</li><li>updated：数据更新时调用，发生在虚拟DOM重新渲染和打补丁之后</li><li>beforeDestroy：实例销毁之前调用</li><li>destroyed：实例销毁之后调用</li></ul></li></ul><h3 id="27-组件"><a href="#27-组件" class="headerlink" title="27.组件"></a>27.组件</h3><ul><li>三大步骤：<ul><li>1.定义组件</li><li>2.注册组件Vue.component()注册组件</li><li>3.使用组件</li></ul></li><li>定义组件：<ul><li>组件是一个对象，包含三个选项：<ul><li>template：组件的模板</li><li>data：组件的属性</li><li>methods：组件的方法</li></ul></li></ul></li><li>注册组件：<ul><li>局部注册：new Vue的时候传入components选项，注册局部组件</li><li>全局注册：Vue.component()注册全局组件</li></ul></li><li>使用组件：<ul><li>&lt;组件名&gt;&lt; &#x2F;组件名&gt;<br><code>注意：</code><blockquote><p><code>关于组件名：</code></p><blockquote><p><code>一个单词组成的：</code></p><blockquote><p><code>首字母小写、首字母大写</code></p></blockquote><p><code>多个单词组成的：</code></p><blockquote><p><code>短横线连接</code><br><code>CamelCase写法，两个单词首字母大写</code></p></blockquote></blockquote></blockquote></li></ul></li></ul><h3 id="28-单文件组件"><a href="#28-单文件组件" class="headerlink" title="28.单文件组件"></a>28.单文件组件</h3><ul><li>vue文件</li><li>一个文件就是一个组件，包含template、script、style三个部分</li><li>同时一个大组件可以包含多个小组件</li><li>有一个名为APP的组件管理所有组件</li><li>组件需要export default导出，才能在其他组件中使用</li></ul><h3 id="29-ref"><a href="#29-ref" class="headerlink" title="29.ref"></a>29.ref</h3><ul><li>作用：获取组件实例或元素</li><li>语法：ref&#x3D;”xxx”</li><li>备注：<ul><li>1.用在标签元素上，与id属性类似，可以获取元素</li><li>2.用在组件上，可以获取组件实例vm</li></ul></li></ul><h3 id="30-props"><a href="#30-props" class="headerlink" title="30.props"></a>30.props</h3><ul><li>简单接收:<br>  props:[‘name’,’age’]</li><li>对象接收(接收+限制):<ul><li>props:{<br>  name:String,<br>  age:Number<br>}</li></ul></li><li>接收+限制+默认值:<ul><li>props:{<br>  name:{<br>  type:String,<br>  required:true,<br>  default:’默认值’<br>  }<br>  }</li></ul></li></ul><h3 id="31-mixin"><a href="#31-mixin" class="headerlink" title="31.mixin"></a>31.mixin</h3><ul><li>能够将重复的代码抽取到一个文件中，然后在多个组件中使用</li><li>语法：<ul><li>1.定义mixin：<ul><li>定义一个对象，包含多个选项</li><li>选项可以是data、methods、computed、watch等</li></ul></li><li>2.使用mixin：<ul><li>直接在组件中使用mixins选项，传入mixin对象</li><li>也可以在组件中使用mixins选项，传入多个mixin对象</li></ul></li></ul></li><li>注意：<ul><li>1.mixin对象中的选项，会覆盖组件自身的同名选项</li><li>2.mixin对象中的选项，不会影响组件的生命周期</li><li>3.mixin对象中的选项，不会影响父组件和子组件的通信</li></ul></li></ul><h3 id="32-插件"><a href="#32-插件" class="headerlink" title="32.插件"></a>32.插件</h3><ul><li>作用：扩展Vue的功能</li><li>语法：<ul><li>1.定义插件：<ul><li>定义一个对象，包含install方法</li><li>install方法接收Vue构造函数和options对象</li><li>install方法的作用：<ul><li>1.<code>全局过滤器 Vue.filter()</code></li><li>2.<code>全局指令 Vue.directive()</code></li><li>3.<code>全局混入 Vue.mixin()</code></li><li>4.<code>全局实例方法 Vue.prototype.$xxx()</code></li></ul></li></ul></li><li>2.使用插件：<ul><li>直接使用插件，传入Vue构造函数和options对象</li><li>也可以在Vue.use()方法中传入插件对象</li></ul></li></ul></li></ul><h3 id="33-scoped样式"><a href="#33-scoped样式" class="headerlink" title="33.scoped样式"></a>33.scoped样式</h3><ul><li>作用：隔离样式，防止样式污染</li><li>语法：<ul><li>1.在style标签上添加scoped属性</li></ul></li></ul><h3 id="34-案例分析"><a href="#34-案例分析" class="headerlink" title="34.案例分析"></a>34.案例分析</h3><ul><li>组件化编码流程<ul><li>1.拆分静态组件：组件按照功能拆分，不易过于粗糙，也不宜过于细致，命名不要与html元素重复</li><li>2.实现动态组件：考虑好数据的存放位置，数据是一个组件在使用，还是一系列组件在使用<ul><li>1）一个组件使用，放在自己内部就好</li><li>2）一系列组件使用，放在他们的父组件中，通过props传递数据</li></ul></li><li>3.实现交互：从绑定事件开始</li></ul></li><li>props适用于：<ul><li>1.父组件&#x3D;&#x3D;&gt;子组件传值</li><li>2.子组件&#x3D;&#x3D;&gt;父组件传值（需要先在父组件定义一个方法，然后在子组件调用）</li></ul></li><li>v-model的注意事项：v-model绑定的值不可以是props传过来的值，因为props传值不可以修改</li><li>props传值时，若是对象类型，修改对象的属性时，Vue不会报错，但是不推荐这样做，毕竟不合规则</li></ul><h3 id="35-WebStorage"><a href="#35-WebStorage" class="headerlink" title="35.WebStorage"></a>35.WebStorage</h3><ul><li>setItem(key,value)：设置存储项</li><li>getItem(key)：获取存储项</li><li>removeItem(key)：删除存储项</li><li>clear()：清空存储</li><li>sessionStorage：只在当前会话（窗口）有效，关闭浏览器窗口后，数据清空</li><li>localStorage：除非手动删除，否则数据永久保存</li><li>注意：<ul><li>1.存储内容大小一般支持5M左右</li><li>2.存储内容只能是字符串</li><li>3.存储内容只能存储在同源的域名下</li></ul></li></ul><h3 id="36-组件自定义事件"><a href="#36-组件自定义事件" class="headerlink" title="36.组件自定义事件"></a>36.组件自定义事件</h3><ul><li>组件间的通信方式：适用于子组件&#x3D;&#x3D;&gt;父组件</li><li>在父组件中绑定组件自定义事件，在子组件中触发组件自定义事件</li><li>绑定方式：<ul><li>1.<code>&lt;demo @xxx=&quot;test&quot;&gt;</code></li><li>2.<code>&lt;demo ref=&quot;demo&quot;&gt;</code>…..<code>mounted()&#123;this.$refs.demo.$on(&#39;xxx&#39;,this.test)&#125;</code></li><li>若要求只能触发一次，可以使用once修饰符，或者$once()方法</li></ul></li><li>触发自定义事件：<code>this.$emit(&#39;xxx&#39;,参数)</code></li><li>解绑自定义事件：<code>this.$off(&#39;xxx&#39;)</code></li><li>使用原生事件，可以用native修饰符</li></ul><h3 id="37-全局事件总线"><a href="#37-全局事件总线" class="headerlink" title="37.全局事件总线"></a>37.全局事件总线</h3><ul><li>安装全局事件总线：<br><code>new Vue(&#123;</code><br><code>.......</code><br><code>beforeCreate()&#123;</code><br><code>    Vue.prototype.$bus = new Vue()</code><br><code>&#125;</code><br><code>&#125;)</code></li><li>使用全局事件总线：<ul><li>接收数据<br>  <code>methods:&#123;</code><br>  <code>demo()&#123;&#125;</code><br>  <code>&#125;</code><br>  <code>mounted()&#123;</code><br>  <code>    this.$bus.$on(&#39;xxx&#39;,this.demo)</code><br>  <code>&#125;</code></li><li>发送数据<br>  <code>this.$bus.$emit(&#39;xxx&#39;,参数)</code></li></ul></li><li>注意：<ul><li>1.全局事件总线，可以跨组件通信</li><li>2.全局事件总线，可以实现跨越多层级的通信</li><li>3.全局事件总线，不建议过度使用，会造成命名冲突，可读性差</li></ul></li></ul><h3 id="38-消息的订阅与发布"><a href="#38-消息的订阅与发布" class="headerlink" title="38.消息的订阅与发布"></a>38.消息的订阅与发布</h3><ul><li>一种组件间通信的方式，适合于任意组件间通信</li><li>使用步骤：<ul><li>1.安装：<code>npm i pubsub-js</code></li><li>2.导入：<code>import PubSub from &#39;pubsub-js&#39;</code></li><li>3.订阅：<code>PubSub.subscribe(&#39;主题名&#39;,function(msg,data)&#123;&#125;)</code></li><li>4.发布：<code>PubSub.publish(&#39;主题名&#39;,参数)</code></li><li>5.注销：<code>PubSub.unsubscribe(&#39;主题id&#39;)</code></li></ul></li></ul><h3 id="39-动画效果"><a href="#39-动画效果" class="headerlink" title="39.动画效果"></a>39.动画效果</h3><ul><li>作用：在插入，更新或者移除DOM元素时，在合适的时候给元素添加样式类名</li><li>语法：<ul><li>Enter:<code>v-enter-active</code> <code>v-enter;v-enter-to</code></li><li>Leave:<code>v-leave-active</code> <code>v-leave;v-leave-to</code></li></ul></li><li>写法：<ul><li>1.准备好样式：<br>  1）元素进入的样式<br>  2）元素离开的样式</li><li>2.使用<code>&lt;transition&gt;</code>包裹要过度的元素，并且配置name属性<br>  <code>&lt;transition name=&quot;xxx&quot;&gt;</code><br>  <code>    &lt;div v-if=&quot;show&quot;&gt;</code><br>  <code>        内容</code></li></ul><p>  <code>    &lt;/div&gt;</code><br>  <code>&lt;/transition&gt;</code></p><ul><li>3.备注：<br>  多个元素过度，使用transition-group组件，并且指定key属性</li></ul></li></ul><h3 id="40-配置技术-代理"><a href="#40-配置技术-代理" class="headerlink" title="40.配置技术(代理)"></a>40.配置技术(代理)</h3><ul><li>方法一：<br>  在vue.config.js中配置<br>  <code>devServer:&#123;</code><br>  <code>    proxy:http://localhost:5000</code><br>  <code>&#125;</code></li><li>说明：<ul><li>1.优点：简单</li><li>2.缺点：无法配置多个代理，不能灵活的控制请求是否代理</li><li>3.工作方式：请求时优先请求前端资源，若自身没有此项资源，再向外请求</li></ul></li><li>方法二：<br>  在vue.config.js中配置<br>  <code> devServer:&#123;</code><br>  <code>    devServer:&#123;</code><br>  <code>    proxy:&#123;</code><br>  <code>        &#39;/api&#39;:&#123;</code><br>  <code>            target:&#39;http://localhost:5000&#39;,</code><br>  <code>            pathRewrite:&#123;&#39;^/api&#39;:&#39;&#39;&#125;</code><br>  <code>            changeOrigin:true</code><br>  <code>             &#125;</code><br>  <code>        &#125;</code><br>  <code>    &#125;</code><br>  <code>&#125;</code></li><li>说明：<ul><li>1.优点：可以配置多项代理，可以灵活控制是否代理</li><li>2.缺点：配置稍微繁琐，请求时必须加前缀</li></ul></li></ul><h3 id="40-插槽"><a href="#40-插槽" class="headerlink" title="40.插槽"></a>40.插槽</h3><ul><li>作用：让父组件可以向子组件插入html结构，也是一种组件间通信的方式，适用于父组件&#x3D;&#x3D;&gt;子组件</li><li>分类：默认插槽、具名插槽、作用域插槽</li></ul><h3 id="41-路由"><a href="#41-路由" class="headerlink" title="41.路由"></a>41.路由</h3><ul><li>理解：一个路由就是一组映射关系，多个路由需要路由器进行管理</li><li>前端路由：key是路径，value是组件</li><li>安装：<code>npm i vue-router</code></li><li>应用：<code>Vue.use(VueRouter)&#123;routers:[]&#125;</code></li><li>路由组件一般放在pages文件夹下，每个页面一个组件；一般组件放在components文件夹下</li><li>切换是将组件销毁，需要时在进行挂载</li><li>每个组件都有<code>自己的$route</code>属性，存储自己的路由信息</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>获取</li></ul><h3 id="42-多级路由"><a href="#42-多级路由" class="headerlink" title="42.多级路由"></a>42.多级路由</h3><ul><li>配置在一级路由的children选项中</li><li>跳转规则要写完整</li></ul><h3 id="43-路由query参数"><a href="#43-路由query参数" class="headerlink" title="43.路由query参数"></a>43.路由query参数</h3><ul><li>路由路径中带有参数，可以通过<code>$route.query</code>获取</li><li>跳转时，可以通过<code>:to=&quot;&#123;path:&#39;路径&#39;,query:&#123;参数名:参数值&#125;&#125;</code>传递参数</li></ul><h3 id="44-命名路由"><a href="#44-命名路由" class="headerlink" title="44.命名路由"></a>44.命名路由</h3><ul><li>在配置路由时，给路由添加name属性</li><li>配置后，可以在跳转时用name属性，代替path属性，简化跳转路径</li></ul><h3 id="45-路由params参数"><a href="#45-路由params参数" class="headerlink" title="45.路由params参数"></a>45.路由params参数</h3><ul><li>配置在路由路径中，通过<code>/:参数名</code>获取</li><li>跳转时，可以通过<code>:to=&quot;&#123;name:&#39;路由名&#39;,params:&#123;参数名:参数值&#125;&#125;</code>传递参数（路径只能通过name属性跳转，不可以用path属性）</li></ul><h3 id="46-路由的props"><a href="#46-路由的props" class="headerlink" title="46.路由的props"></a>46.路由的props</h3><ul><li>1.第一种写法：对象形式<code>props:&#123;a:1,b:&quot;hello&quot;&#125;</code>，都会以props形式传递给组件</li><li>2.第二种写法：布尔值形式<code>props:ture</code>，会把该路由收到的所有<code>params</code>参数，以props形式传递给组件</li><li>3.第三种写法：函数形式<code>props:function($route)&#123;return &#123;a:$route.quary.a&#125;&#125;</code>，</li></ul><h3 id="47-路由replace"><a href="#47-路由replace" class="headerlink" title="47.路由replace"></a>47.路由replace</h3><ul><li>作用：替换当前路由，不会留下历史记录</li><li>在router-link上添加replace属性</li></ul><h3 id="48-编程式路由导航"><a href="#48-编程式路由导航" class="headerlink" title="48.编程式路由导航"></a>48.编程式路由导航</h3><ul><li>作用：通过代码控制路由的跳转</li><li>跳转语法：<code>this.$router.push()</code>或者<code>this.$router.replace()</code></li><li>回退和前进：<code>this.$router.back()</code>或者<code>this.$router.forward()</code></li><li>go方法：<code>this.$router.go(n)</code>n为正数，向前走n步；n为负数，向后走n步</li></ul><h3 id="49-缓存路由"><a href="#49-缓存路由" class="headerlink" title="49.缓存路由"></a>49.缓存路由</h3><ul><li>作用：在切换路由时，缓存当前路由组件，下次进入时直接渲染缓存的组件</li><li>实现：用<code>keep-alive</code>元素包裹<code>router-view</code>，并设置<code>include</code>属性，值为要缓存的组件名</li></ul><h3 id="50-两个新的生命周期函数"><a href="#50-两个新的生命周期函数" class="headerlink" title="50.两个新的生命周期函数"></a>50.两个新的生命周期函数</h3><ul><li>activated：组件激活时调用，只调用一次（从无到有）</li><li>deactivated：组件失活时调用，只调用一次（从有到无）</li></ul><h3 id="51-路由工作的模式"><a href="#51-路由工作的模式" class="headerlink" title="51.路由工作的模式"></a>51.路由工作的模式</h3><p><img src="/../images/Vue2-51.1.png" alt="路由工作的模式"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2024/10/21/Promise/"/>
    <url>/2024/10/21/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h3 id="1-Promise-基础使用"><a href="#1-Promise-基础使用" class="headerlink" title="1.Promise 基础使用"></a>1.Promise 基础使用</h3><ul><li>promise 是一个构造函数</li><li>其中接收一个参数 exexcutor 执行器函数，达到预期结果后，调用 resolve 函数，将结果传递给 promise；如果出现错误，调用 reject 函数，将错误信息传递给 promise。</li><li>.then() 方法用于处理 promise 成功&#x2F;失败的结果，</li><li>.catch() 方法用于处理 promise 失败的结果。</li><li>组合写法：.then()成功；.catch()失败。</li><li><img src="/images/Promise-1.1.png" alt="promise基础"></li><li><img src="/images/Promise-1.2.png" alt="promise基础"></li></ul><h3 id="2-Promise-三个状态"><a href="#2-Promise-三个状态" class="headerlink" title="2.Promise 三个状态"></a>2.Promise 三个状态</h3><ul><li>pending（等待）：初始状态，既没有被执行也没有被拒绝。</li><li>fulfilled（已完成）：promise 成功执行，并返回一个值。</li><li>rejected（已拒绝）：promise 执行失败，并抛出一个错误。</li><li>仅两种转化状态：</li><li>1.pending -&gt; fulfilled：调用 resolve 函数，将结果传递给 promise。</li><li>2.pending -&gt; rejected：调用 reject 函数，将错误信息传递给 promise。</li></ul><h3 id="3-Promise-的结果"><a href="#3-Promise-的结果" class="headerlink" title="3.Promise 的结果"></a>3.Promise 的结果</h3><ul><li>resolve 函数中可以传递成功获取的结果，.then() 方法中可以接收成功的结果。</li><li>reject 函数中可以传递失败的原因，.catch() 方法中可以接收失败的原因。</li><li>注意：如果 promise 已经处于 fulfilled 或 rejected 状态，再调用 resolve 或 reject 不会起作用，而是会被忽略。</li></ul><h3 id="4-Promise封装ajax"><a href="#4-Promise封装ajax" class="headerlink" title="4.Promise封装ajax"></a>4.Promise封装ajax</h3><ul><li><img src="/images/Promise-4.1.png" alt="promise封装ajax"></li><li><img src="/images/Promise-4.2.png" alt="promise封装ajax"></li></ul><h3 id="5-Promise-resolve"><a href="#5-Promise-resolve" class="headerlink" title="5.Promise.resolve()"></a>5.Promise.resolve()</h3><ul><li>将一个普通对象或值转换成一个 Promise 对象，状态为 fulfilled。</li><li>如果参数是一个 Promise 对象，则直接返回该对象。</li><li>用途：设置缓存结构，减小后端压力</li></ul><h3 id="6-Promise-reject"><a href="#6-Promise-reject" class="headerlink" title="6.Promise.reject()"></a>6.Promise.reject()</h3><ul><li>将一个普通对象或值转换成一个 Promise 对象，状态为 rejected。</li><li>如果参数是一个 Promise 对象，则直接返回该对象。</li><li>用途：对于成功的promise对象中的个例进行错误处理</li></ul><h3 id="7-Promise链式调用"><a href="#7-Promise链式调用" class="headerlink" title="7.Promise链式调用"></a>7.Promise链式调用</h3><ul><li>.then()返回的新 promise 对象，可以继续调用 .then() 方法。</li><li>不执行return，则返回undefined,fulfilled状态的</li><li>执行return Promise.resolve(value)，则返回value,fulfilled状态的</li><li>执行return Promise.reject(reason)，则返回reason,rejected状态的</li></ul><h3 id="8-Promise-all"><a href="#8-Promise-all" class="headerlink" title="8.Promise.all()"></a>8.Promise.all()</h3><ul><li>用于将多个 Promise 实例，包装成一个新的 Promise 实例。</li><li>只有当所有 Promise 实例都成功，才会成功，否则失败。</li><li>成功时返回一个数组，对应每个 Promise 实例的返回值。</li><li>失败时返回第一个失败的 Promise 实例的错误信息。</li></ul><h3 id="9-Promise-race"><a href="#9-Promise-race" class="headerlink" title="9.Promise.race()"></a>9.Promise.race()</h3><ul><li>用于将多个 Promise 实例，包装成一个新的 Promise 实例。</li><li>其中一个实例率先改变状态，则新的 Promise 实例也会改变状态。</li><li>用途：超时判定</li></ul><h3 id="10-Promise-allSettled"><a href="#10-Promise-allSettled" class="headerlink" title="10.Promise.allSettled()"></a>10.Promise.allSettled()</h3><ul><li>用于将多个 Promise 实例，包装成一个新的 Promise 实例。</li><li>无论 Promise 实例是成功还是失败，都会在.then()中接收到相应的结果。</li></ul><h3 id="11-Promise-any"><a href="#11-Promise-any" class="headerlink" title="11.Promise.any()"></a>11.Promise.any()</h3><ul><li>用于将多个 Promise 实例，包装成一个新的 Promise 实例。</li><li>只有当所有 Promise 实例都失败，才会失败，否则成功。   </li><li>用途：多平台的授权登录，只要有一个平台授权成功，则登录成功。</li></ul><h3 id="12-finally"><a href="#12-finally" class="headerlink" title="12.finally()"></a>12.finally()</h3><ul><li>用于指定不管 Promise 实例是成功还是失败，都会执行的操作。</li><li>无论 Promise 实例是成功还是失败，都会执行指定的操作。</li><li>是一种特殊的透明状态，后面接.then()或.catch()方法，接收的值是之前return的值。</li></ul><h3 id="13-Async-Await"><a href="#13-Async-Await" class="headerlink" title="13.Async&#x2F;Await"></a>13.Async&#x2F;Await</h3><ul><li>异步编程的语法糖，可以让异步操作变得更加方便。</li><li>异步函数返回一个 Promise 对象，可以使用 await 关键字获取该 Promise 对象的值。</li><li>异步函数中使用 await 关键字，等同于将该函数暂停，等待 Promise 对象状态改变，再恢复执行。</li><li>try…catch 结构，可以捕获异常。</li><li><img src="/images/Promise-13.1.png" alt="async/await"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6</title>
    <link href="/2024/10/19/ES6/"/>
    <url>/2024/10/19/ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h3 id="1-let-和-const-命令"><a href="#1-let-和-const-命令" class="headerlink" title="1. let 和 const 命令"></a>1. let 和 const 命令</h3><ul><li>let <ul><li>无变量提升，是一个块级作用域，不能重复声明</li></ul></li><li>const <ul><li>无变量提升，是一个块级作用域，不能重复声明</li><li>声明常量，一旦声明，不能修改值</li><li>声明对象时，不能直接修改对象，但是可以修改对象的属性值</li></ul></li><li>建议：在默认情况下使用const，只有在需要修改变量时才使用let。</li></ul><h3 id="2-模板字符串"><a href="#2-模板字符串" class="headerlink" title="2.模板字符串"></a>2.模板字符串</h3><ul><li><img src="/images/ES6-str.png" alt="模板字符串"></li></ul><h3 id="3-强大函数"><a href="#3-强大函数" class="headerlink" title="3.强大函数"></a>3.强大函数</h3><ul><li><p>默认值<br><img src="/images/ES6-f1.png" alt="默认值"></p></li><li><p>默认值可以是函数<br><img src="/images/ES6-f2.png" alt="默认值函数"></p></li><li><p>剩余参数：使用…keys参数，可以获取函数中余下的参数<br><img src="/images/ES6-f3.png" alt="剩余参数"></p></li><li><p>扩展运算符：将一个数组进行分割，并将各个项作为分离参数传给函数<br><img src="/images/ES6-f4.png" alt="扩展运算符"></p></li><li><p>箭头函数：(&#x3D;&gt;)可以简化函数定义，并且不绑定this，可以用作回调函数<br><img src="/images/ES6-f5.png" alt="箭头函数"></p></li></ul><h3 id="4-解构赋值"><a href="#4-解构赋值" class="headerlink" title="4.解构赋值"></a>4.解构赋值</h3><ul><li>对赋值运算符的一种扩展<br><img src="/images/ES6-jg1.png" alt="解构赋值"></li></ul><p><img src="/images/ES6-jg2.png" alt="解构赋值"></p><h3 id="5-扩展对象功能"><a href="#5-扩展对象功能" class="headerlink" title="5.扩展对象功能"></a>5.扩展对象功能</h3><ul><li><p><img src="/images/ES6-obj1.png" alt="扩展对象功能"></p></li><li><p><img src="/images/ES6-obj2.png" alt="扩展对象功能"></p></li></ul><h3 id="6-Symbol对象"><a href="#6-Symbol对象" class="headerlink" title="6.Symbol对象"></a>6.Symbol对象</h3><ul><li><p>一种新的原始数据类型，是通过Symbol函数生成的</p></li><li><p>它是一种独一无二的值，可以作为对象属性的标识符，可以保证对象属性的私密性</p></li><li><p>最大用途，定义对象的私有变量</p></li><li><p><img src="/images/ES6-sy1.png" alt="Symbol对象"></p></li><li><p><img src="/images/ES6-sy2.png" alt="获取Symbol声明的属性名"></p></li></ul><h3 id="7-Set数据结构"><a href="#7-Set数据结构" class="headerlink" title="7.Set数据结构"></a>7.Set数据结构</h3><ul><li>Set：类似数组，但是成员的值都是唯一的，没有重复的值</li><li>Map：类似对象，是一对键值对的集合，类似于哈希表</li><li><img src="/images/ES6-set1.png" alt="Set"></li><li><img src="/images/ES6-set2.png" alt="Set转化为数组"></li></ul><h3 id="8-Map数据结构"><a href="#8-Map数据结构" class="headerlink" title="8.Map数据结构"></a>8.Map数据结构</h3><ul><li>Map：类似对象，是一对键值对的集合，类似于哈希表</li><li><img src="/images/ES6-map1.png" alt="Map"></li></ul><h3 id="9-数组的扩展"><a href="#9-数组的扩展" class="headerlink" title="9.数组的扩展"></a>9.数组的扩展</h3><ul><li>from()：将类数组对象转换为数组</li><li>of()：将一组值转换为数组</li><li>copyWithin()：浅复制数组的一部分到同一数组中的另一个位置</li><li>find()：返回数组中满足条件的第一个元素</li><li>findIndex()：返回数组中满足条件的第一个元素的索引</li><li>keys，values，entries()：返回数组的键名，键值，键值对</li><li><img src="/images/ES6-arr1.png" alt="数组的扩展"></li><li><img src="/images/ES6-arr2.png" alt="数组的扩展"></li><li><img src="/images/ES6-arr3.png" alt="数组的扩展"></li><li><img src="/images/ES6-arr4.png" alt="数组的扩展"></li><li><img src="/images/ES6-arr5.png" alt="数组的扩展"></li></ul><h3 id="10-迭代器"><a href="#10-迭代器" class="headerlink" title="10.迭代器"></a>10.迭代器</h3><ul><li>一种接口，用来访问集合对象的元素，通过Symbol.iterator属性来访问，通过next()方法来获取下一个元素</li><li>用于遍历数组结构的指针</li><li><img src="/images/ES6-dd1.png" alt="迭代器"></li></ul><h3 id="11-生成器"><a href="#11-生成器" class="headerlink" title="11.生成器"></a>11.生成器</h3><ul><li>一种特殊的函数，使用yield关键字来挂起函数</li><li>为了改变执行流程，可以暂停函数的执行，并恢复函数的执行</li><li>一般用于异步编程</li><li><img src="/images/ES6-yield1.png" alt="生成器"></li><li><img src="/images/ES6-yield2.png" alt="生成器"></li></ul><h3 id="12-Promise对象"><a href="#12-Promise对象" class="headerlink" title="12.Promise对象"></a>12.Promise对象</h3><ul><li>相当于一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果</li><li>各种异步操作都可以用同样的方法进行处理</li><li>特点：<ul><li>对象的状态不受外界影响：pending（进行中），fulfilled（已成功），rejected（已失败）</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果</li></ul></li></ul><h3 id="13-async-await"><a href="#13-async-await" class="headerlink" title="13.async&#x2F;await"></a>13.async&#x2F;await</h3><ul><li>异步编程的终极解决方案</li><li>async会返回一个Promise对象，是Generator函数的语法糖</li><li>await关键字后面可以跟Promise对象，表示等待Promise对象的状态变为resolved，然后才会继续执行后面的语句</li><li>异步函数返回的是Promise对象，可以使用then()方法添加回调函数</li><li><img src="/images/ES6-async1.png" alt="async/await"></li></ul><h3 id="14-Class"><a href="#14-Class" class="headerlink" title="14.Class"></a>14.Class</h3><ul><li><p>ES6中引入的新语法，用来定义类</p></li><li><p>类可以用来创建自定义的构造函数，实例属性和方法</p></li><li><p>类可以继承其他类，可以实现多态</p></li><li><p>类可以实现接口，可以对类的实例进行类型检查</p></li><li><p><img src="/images/ES6-class1.png" alt="Class"></p></li><li><p>继承：extends关键字后面可以跟父类，子类会自动获得父类的属性和方法</p></li><li><p><img src="/images/ES6-class2.png" alt="继承"></p></li><li><p><img src="/images/ES6-class3.png" alt="继承"></p></li></ul><h3 id="15-模块化"><a href="#15-模块化" class="headerlink" title="15.模块化"></a>15.模块化</h3><ul><li>模块化是指将一个大程序分解成小的、可管理的、可复用的模块</li><li>ES6模块化方案，主要有以下几种：<ul><li>CommonJS：模块化规范，主要用于服务器端</li><li>AMD：异步模块定义，主要用于浏览器端</li><li>UMD：通用模块定义，同时支持AMD和CommonJS</li><li>ES6模块：模块化方案，主要用于浏览器端和Node.js</li><li>export：用于导出模块成员</li><li>import：用于导入模块成员</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS_high</title>
    <link href="/2024/10/19/JS-high/"/>
    <url>/2024/10/19/JS-high/</url>
    
    <content type="html"><![CDATA[<h1 id="js高级"><a href="#js高级" class="headerlink" title="js高级"></a>js高级</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><h3 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1 分类"></a>1.1 分类</h3><h4 id="1-1-1-基本类型"><a href="#1-1-1-基本类型" class="headerlink" title="1.1.1 基本类型"></a>1.1.1 基本类型</h4><ul><li>数值类型：Number</li><li>字符串类型：String</li><li>布尔类型：Boolean</li><li>空类型：Null</li><li>未定义类型：Undefined</li></ul><h4 id="1-1-2-对象（引用）类型"><a href="#1-1-2-对象（引用）类型" class="headerlink" title="1.1.2 对象（引用）类型"></a>1.1.2 对象（引用）类型</h4><ul><li>Object ：任意对象</li><li>array ：（特别的对象，数值下标，内部有序）</li><li>function ：函数（特别的对象，可以运行）</li></ul><h3 id="1-2-判断"><a href="#1-2-判断" class="headerlink" title="1.2 判断"></a>1.2 判断</h3><ul><li>typeof：判断基本类型 返回数据类型的字符串表达<ul><li>可以判断 null &#x2F; undefined &#x2F; 数值 &#x2F; 字符串 &#x2F; 布尔值</li></ul></li><li>instanceof：判断对象类型<ul><li>可以判断数组、函数、对象</li></ul></li><li>&#x3D;&#x3D;&#x3D;：判断值和类型<ul><li>可以判断 udefine、null</li></ul></li></ul><h3 id="1-3-类型剖析"><a href="#1-3-类型剖析" class="headerlink" title="1.3 类型剖析"></a>1.3 类型剖析</h3><h4 id="1-3-1-udefine和null的区别？"><a href="#1-3-1-udefine和null的区别？" class="headerlink" title="1.3.1 udefine和null的区别？"></a>1.3.1 udefine和null的区别？</h4><ul><li>undefined：变量声明但未赋值，值为undefined</li><li>null：定义了，赋值了，变量值为null，表示空值</li></ul><h4 id="1-3-2-什么时候给变量赋值为null？"><a href="#1-3-2-什么时候给变量赋值为null？" class="headerlink" title="1.3.2 什么时候给变量赋值为null？"></a>1.3.2 什么时候给变量赋值为null？</h4><ul><li>1.初始赋值为null，一般表明将要赋值为对象</li><li>2.最后赋值为null，表示变量不再有意义，供垃圾回收器回收内存</li></ul><h4 id="1-3-3-严格区别变量类型与数据类型？"><a href="#1-3-3-严格区别变量类型与数据类型？" class="headerlink" title="1.3.3 严格区别变量类型与数据类型？"></a>1.3.3 严格区别变量类型与数据类型？</h4><ul><li>数据类型：基本类型、对象类型</li><li>变量类型（变量内存值的类型）：<ul><li>基本类型：保存的就是基本类型的数据</li><li>引用类型：保存的是地址值</li></ul></li></ul><h2 id="2-数据、变量、内存"><a href="#2-数据、变量、内存" class="headerlink" title="2 数据、变量、内存"></a>2 数据、变量、内存</h2><h4 id="2-1-1-什么是数据？"><a href="#2-1-1-什么是数据？" class="headerlink" title="2.1.1 什么是数据？"></a>2.1.1 什么是数据？</h4><ul><li>存储在内存中代表特定信息的“东西”，本质上是01字符串</li><li>数据的特点：<ul><li>可传递</li><li>可运算</li><li>可存储</li></ul></li></ul><h4 id="2-1-2-什么是内存？"><a href="#2-1-2-什么是内存？" class="headerlink" title="2.1.2 什么是内存？"></a>2.1.2 什么是内存？</h4><ul><li>内存条通电以后产生的可存储空间（临时的）</li><li>内存的产生与死亡：内存条（电路板）&#x3D;&#x3D;&gt;通电&#x3D;&#x3D;&gt;产生内存&#x3D;&#x3D;&gt;存储数据&#x3D;&#x3D;&gt;程序运行，处理数据&#x3D;&#x3D;&gt;断电&#x3D;&#x3D;&gt;内存空间和数据消失</li><li>内存分类：<ul><li>栈：全局变量&#x2F;局部变量</li><li>堆：对象</li></ul></li></ul><h4 id="2-1-3-什么是变量？"><a href="#2-1-3-什么是变量？" class="headerlink" title="2.1.3 什么是变量？"></a>2.1.3 什么是变量？</h4><ul><li>可变化的量，由变量名和变量值组成</li><li>每个变量都对应一块小内存，变量名用来查找对应内存，变量值存放在内存中</li></ul><h4 id="2-2-1-内存、数据、变量三者的关系"><a href="#2-2-1-内存、数据、变量三者的关系" class="headerlink" title="2.2.1 内存、数据、变量三者的关系"></a>2.2.1 内存、数据、变量三者的关系</h4><ul><li>内存是用来存储数据的空间</li><li>变量是内存的标识</li></ul><h4 id="2-2-2-var-a-xxx，a中到底保存了什么？"><a href="#2-2-2-var-a-xxx，a中到底保存了什么？" class="headerlink" title="2.2.2 var a&#x3D;xxx，a中到底保存了什么？"></a>2.2.2 var a&#x3D;xxx，a中到底保存了什么？</h4><ul><li>xxx是基本数据，那么a中保存的就是基本数据的值</li><li>xxx是对象，那么a中保存的就是引用数据在内存中的地址值</li><li>xxx是一个变量，保存的xxx内存的内容（基本数据&#x2F;地址值）</li></ul><h4 id="2-2-3-关于引用变量赋值问题"><a href="#2-2-3-关于引用变量赋值问题" class="headerlink" title="2.2.3 关于引用变量赋值问题"></a>2.2.3 关于引用变量赋值问题</h4><ul><li>2个引用变量指向同一个对象，修改其中一个变量，另一个变量也会跟着改变</li><li>2个引用变量指向不同的对象，修改其中一个变量，另一个变量不会跟着改变</li></ul><h4 id="2-3-1-js在调用函数传递变量参数的时候，是值传递还是参数传递？"><a href="#2-3-1-js在调用函数传递变量参数的时候，是值传递还是参数传递？" class="headerlink" title="2.3.1 js在调用函数传递变量参数的时候，是值传递还是参数传递？"></a>2.3.1 js在调用函数传递变量参数的时候，是值传递还是参数传递？</h4><ul><li>值（基本&#x2F;地址值）传递</li></ul><h4 id="2-3-2-js引擎如何管理内存？"><a href="#2-3-2-js引擎如何管理内存？" class="headerlink" title="2.3.2 js引擎如何管理内存？"></a>2.3.2 js引擎如何管理内存？</h4><ul><li><p>内存生命周期</p><ul><li>分配小的内存空间，得到他的使用权</li><li>存储数据，可以反复进行操作</li><li>释放小内存空间</li></ul></li><li><p>释放内存</p><ul><li>局部变量：函数执行完毕，变量内存空间自动释放</li><li>对象：成为垃圾对象&#x3D;&#x3D;&gt;垃圾回收期回收</li></ul></li></ul><h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h2><h4 id="3-1-1-什么是对象？"><a href="#3-1-1-什么是对象？" class="headerlink" title="3.1.1 什么是对象？"></a>3.1.1 什么是对象？</h4><ul><li>多个对象的封装体</li><li>用来保存多个数据的容器</li><li>一个对象代表显示中的一个事物</li></ul><h4 id="3-1-2-为什么要用对象？"><a href="#3-1-2-为什么要用对象？" class="headerlink" title="3.1.2 为什么要用对象？"></a>3.1.2 为什么要用对象？</h4><ul><li>统一管理多个数据</li></ul><h4 id="3-1-3-对象的组成"><a href="#3-1-3-对象的组成" class="headerlink" title="3.1.3 对象的组成"></a>3.1.3 对象的组成</h4><ul><li>属性：属性名（字符串）和属性值（任意类型）</li><li>方法：一种特殊的方法（属性值是一个函数）</li></ul><h4 id="3-1-4-如何访问对象的内部数据？"><a href="#3-1-4-如何访问对象的内部数据？" class="headerlink" title="3.1.4 如何访问对象的内部数据？"></a>3.1.4 如何访问对象的内部数据？</h4><ul><li>.属性名：访问对象的属性值，有时不能使用</li><li>[“属性名”]：访问对象的属性值，任何情况通用</li><li>对象.方法名()：调用对象的某个方法</li></ul><h4 id="3-2-1-什么时候必须使用-“属性名”-访问属性？"><a href="#3-2-1-什么时候必须使用-“属性名”-访问属性？" class="headerlink" title="3.2.1 什么时候必须使用[“属性名”]访问属性？"></a>3.2.1 什么时候必须使用[“属性名”]访问属性？</h4><ul><li>属性名包含特殊字符</li><li>属性名是变量</li></ul><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h2><h4 id="4-1-1-什么是函数？"><a href="#4-1-1-什么是函数？" class="headerlink" title="4.1.1 什么是函数？"></a>4.1.1 什么是函数？</h4><ul><li>实现特定功能的n条语句的封装体</li><li>只有函数是可以执行的，其他类型都不能执行</li></ul><h4 id="4-1-2-为什么要用函数？"><a href="#4-1-2-为什么要用函数？" class="headerlink" title="4.1.2 为什么要用函数？"></a>4.1.2 为什么要用函数？</h4><ul><li>提高代码的复用性</li><li>便于阅读交流</li></ul><h4 id="4-1-3-如何定义函数？"><a href="#4-1-3-如何定义函数？" class="headerlink" title="4.1.3 如何定义函数？"></a>4.1.3 如何定义函数？</h4><ul><li>函数声明</li><li>函数表达式</li></ul><h4 id="4-1-4-如何调用（执行）函数？"><a href="#4-1-4-如何调用（执行）函数？" class="headerlink" title="4.1.4 如何调用（执行）函数？"></a>4.1.4 如何调用（执行）函数？</h4><ul><li>test（）：直接调用</li><li>test.call（obj）：通过对象调用</li><li>new test（）：new调用</li><li>test.call&#x2F;apply（obj）：相当于obj.test(),临时让test成为obj的方法，进行调用</li></ul><h2 id="5-回调函数"><a href="#5-回调函数" class="headerlink" title="5.回调函数"></a>5.回调函数</h2><h4 id="5-1-1-什么函数才是回调函数？"><a href="#5-1-1-什么函数才是回调函数？" class="headerlink" title="5.1.1 什么函数才是回调函数？"></a>5.1.1 什么函数才是回调函数？</h4><ul><li>编码者自己定义的函数</li><li>编码者自己没有调用</li><li>但是它（函数）最后执行</li></ul><h4 id="5-1-2-常见的回调函数有哪些？"><a href="#5-1-2-常见的回调函数有哪些？" class="headerlink" title="5.1.2 常见的回调函数有哪些？"></a>5.1.2 常见的回调函数有哪些？</h4><ul><li>dom事件回调函数</li><li>定时器回调函数</li><li>ajax回调函数</li><li>生命周期回调函数</li></ul><h2 id="6-IIFE"><a href="#6-IIFE" class="headerlink" title="6.IIFE"></a>6.IIFE</h2><h4 id="6-1-1-IIFE的理解？"><a href="#6-1-1-IIFE的理解？" class="headerlink" title="6.1.1 IIFE的理解？"></a>6.1.1 IIFE的理解？</h4><ul><li>全称： Immediately Invoked Function Expression（立即调用的函数表达式）</li></ul><h4 id="6-1-2-IIFE的作用？"><a href="#6-1-2-IIFE的作用？" class="headerlink" title="6.1.2 IIFE的作用？"></a>6.1.2 IIFE的作用？</h4><ul><li>隐藏实现</li><li>不会污染全局命名空间</li><li>用来编写js模块化代码</li></ul><h2 id="7-函数中的this"><a href="#7-函数中的this" class="headerlink" title="7.函数中的this"></a>7.函数中的this</h2><h4 id="7-1-1-this是什么？"><a href="#7-1-1-this是什么？" class="headerlink" title="7.1.1 this是什么？"></a>7.1.1 this是什么？</h4><ul><li>任何函数本质上都是通过某个对象调用的，未指定对象时，this就是window</li><li>所有函数内部都有一个this变量</li><li>它的值是调用函数的当前对象</li></ul><h4 id="7-1-2-如何确定this的值？"><a href="#7-1-2-如何确定this的值？" class="headerlink" title="7.1.2 如何确定this的值？"></a>7.1.2 如何确定this的值？</h4><ul><li>test（）：默认调用window</li><li>test.call（obj）：obj调用</li><li>new test()：新创建的对象</li><li>p.test()：p调用</li></ul><h2 id="8-原型与原型链"><a href="#8-原型与原型链" class="headerlink" title="8.原型与原型链"></a>8.原型与原型链</h2><h4 id="8-1-1-函数的property属性图"><a href="#8-1-1-函数的property属性图" class="headerlink" title="8.1.1 函数的property属性图"></a>8.1.1 函数的property属性图</h4><ul><li>每个函数都有一个prototype属性，它默认指向一个object空对象（即称为：原型对象）</li><li>原型对象中有一个constructor属性，指向函数对象</li></ul><h4 id="8-1-2-给原型对象添加属性（一般都是方法）"><a href="#8-1-2-给原型对象添加属性（一般都是方法）" class="headerlink" title="8.1.2 给原型对象添加属性（一般都是方法）"></a>8.1.2 给原型对象添加属性（一般都是方法）</h4><ul><li>作用：函数的所有实例对象自动拥有原型中的属性（方法）</li></ul><h4 id="8-2-1-显式原型与隐式原型"><a href="#8-2-1-显式原型与隐式原型" class="headerlink" title="8.2.1 显式原型与隐式原型"></a>8.2.1 显式原型与隐式原型</h4><ul><li>每个函数function都有一个内部属性prototype，即显示原型</li><li>每个实例对象都有一个__proto__属性，可称之为隐式原型</li><li>对象的隐式原型的值为其对应构造函数的显性原型的值</li><li>总结：<ul><li>函数的prototype属性：在定义函数时自动添加的，默认值是一个空对象</li><li>实例对象的__proto__属性：在创建实例对象时自动添加的，默认值为构造函数的prototype属性值</li><li>程序员能直接操作显示原型，但不能直接操作隐式原型（ES6之前）</li></ul></li></ul><h4 id="8-3-1-原型链"><a href="#8-3-1-原型链" class="headerlink" title="8.3.1 原型链"></a>8.3.1 原型链</h4><ul><li>访问一个对象的属性时：<ul><li>先在自身属性中查找，找到并返回</li><li>如果没有找到，再沿__proto__这条链上不断查找，找到并返回</li><li>如果还没有找到，返回undifined</li></ul></li><li>别名：隐式原型链</li><li>作用：查找对象的属性（方法）</li><li>补充：<ul><li>函数的显示原型指向的对象默认是空object实例对象（但是object不满足）</li><li>所有函数都是Function的实例（包含Function）</li><li>Object的原型对象是原型链尽头</li></ul></li></ul><h4 id="8-3-2-原型链属性"><a href="#8-3-2-原型链属性" class="headerlink" title="8.3.2 原型链属性"></a>8.3.2 原型链属性</h4><ul><li>读取对象的属性值：会自动到原型链上查找</li><li>设置对象的属性值：不会查找原型链，如果当前对象没有此属性，直接添加此属性并设置其值</li><li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</li></ul><h2 id="9-执行上下文与执行上下文栈"><a href="#9-执行上下文与执行上下文栈" class="headerlink" title="9.执行上下文与执行上下文栈"></a>9.执行上下文与执行上下文栈</h2><h4 id="9-1-1-变量提升与函数提升"><a href="#9-1-1-变量提升与函数提升" class="headerlink" title="9.1.1 变量提升与函数提升"></a>9.1.1 变量提升与函数提升</h4><ul><li>变量声明提升<ul><li>通过var定义的变量，在定义语句之前就可以被访问到</li><li>值：undefined</li></ul></li><li>函数声明提升<ul><li>通过function声明的函数，在之前就可以直接调用</li><li>值：函数定义（对象）</li></ul></li></ul><h4 id="9-2-1-执行上下文"><a href="#9-2-1-执行上下文" class="headerlink" title="9.2.1 执行上下文"></a>9.2.1 执行上下文</h4><ul><li>代码分类：<ul><li>全局代码</li><li>函数（局部）代码</li></ul></li><li>全局执行上下文<ul><li>在执行全局代码前将window确定为全局执行上下文</li><li>对全局数据进行预处理<ul><li>var定义的全局变量&#x3D;&#x3D;&gt;undefined，添加为window的属性</li><li>function定义的全局函数&#x3D;&#x3D;&gt;赋值（fun），添加为window的方法</li><li>this&#x3D;&#x3D;&gt;赋值（window）</li></ul></li><li>开始执行上下文</li></ul></li><li>函数执行上下文<ul><li>在调用函数，准备执行函数体之前，创造对应的函数执行上下文对象</li><li>对局部数据进行预处理<ul><li>形参变量&#x3D;&#x3D;&gt;赋值（实参）&#x3D;&#x3D;&gt;添加为执行上下文的属性</li><li>arguements（伪数组）&#x3D;&#x3D;&gt;赋值（实参列表），添加为执行上下文的属性</li><li>var定义的局部变量&#x3D;&#x3D;&gt;undefined，添加为执行上下文属性</li><li>function声明的函数&#x3D;&#x3D;&gt;赋值（fun），添加为执行上下文的方法</li><li>this&#x3D;&#x3D;&gt;赋值（调用函数的对象）</li></ul></li><li>开始执行函数体代码</li></ul></li></ul><h4 id="9-3-1-执行上下文栈"><a href="#9-3-1-执行上下文栈" class="headerlink" title="9.3.1 执行上下文栈"></a>9.3.1 执行上下文栈</h4><ul><li>在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文对象</li><li>在全局执行上下文（window）确定后，将其添加到栈中（即压栈）</li><li>在函数执行上下文创建之后，将其添加到栈中</li><li>在当前函数执行完成后，将栈顶的对象移除栈（即出栈）</li><li>当所有的代码执行完成后，栈只剩下window对象</li></ul><h2 id="10-作用域与作用域链"><a href="#10-作用域与作用域链" class="headerlink" title="10.作用域与作用域链"></a>10.作用域与作用域链</h2><h4 id="10-1-1-作用域的理解"><a href="#10-1-1-作用域的理解" class="headerlink" title="10.1.1 作用域的理解"></a>10.1.1 作用域的理解</h4><ul><li>就是一块“地盘”，一个代码段所在的区域</li><li>他是静态的（相对于上下文对象），在编写代码时就确定了</li></ul><h4 id="10-1-2-作用域的分类"><a href="#10-1-2-作用域的分类" class="headerlink" title="10.1.2 作用域的分类"></a>10.1.2 作用域的分类</h4><ul><li>全局作用域</li><li>函数作用域</li><li>无块级作用域（ES6新增块作用域）</li></ul><h4 id="10-1-3-作用域的作用"><a href="#10-1-3-作用域的作用" class="headerlink" title="10.1.3 作用域的作用"></a>10.1.3 作用域的作用</h4><ul><li>隔离变量，不同作用域下同名变量不会有冲突</li></ul><h4 id="10-2-1-作用域与执行上下文的区别1"><a href="#10-2-1-作用域与执行上下文的区别1" class="headerlink" title="10.2.1 作用域与执行上下文的区别1"></a>10.2.1 作用域与执行上下文的区别1</h4><ul><li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时</li><li>全局执行上下文环境数字哎全局作用域确定之后，JS代码马上执行之前创建</li><li>函数执行上下文环境是在调用函数时，函数体代码执行之前创建</li></ul><h4 id="10-2-2-作用域与执行上下文的区别2"><a href="#10-2-2-作用域与执行上下文的区别2" class="headerlink" title="10.2.2 作用域与执行上下文的区别2"></a>10.2.2 作用域与执行上下文的区别2</h4><ul><li>作用域是静态的，函数定义好了就一直存在，不再变化</li><li>上下文是动态的，函数调用时才创建，函数执行完毕后销毁</li></ul><h4 id="10-2-3-作用域与执行上下文的联系"><a href="#10-2-3-作用域与执行上下文的联系" class="headerlink" title="10.2.3 作用域与执行上下文的联系"></a>10.2.3 作用域与执行上下文的联系</h4><ul><li>上下文环境（对象）是从属于所在的作用域</li><li>全局上下文环境&#x3D;&#x3D;&gt;全局作用域</li><li>函数上下文环境&#x3D;&#x3D;&gt;对应的函数作用域</li></ul><h2 id="11-闭包"><a href="#11-闭包" class="headerlink" title="11.闭包"></a>11.闭包</h2><h4 id="11-1-1-如何产生闭包？"><a href="#11-1-1-如何产生闭包？" class="headerlink" title="11.1.1 如何产生闭包？"></a>11.1.1 如何产生闭包？</h4><ul><li>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量时，就产生了闭包</li></ul><h4 id="11-1-2-闭包到底是什么？"><a href="#11-1-2-闭包到底是什么？" class="headerlink" title="11.1.2 闭包到底是什么？"></a>11.1.2 闭包到底是什么？</h4><ul><li>使用chrome进行查看</li><li>理解一： 闭包是嵌套的内部函数（绝大部分人认为）</li><li>理解二： 包含被引用变量（函数）的对象（极少数人认为）</li><li>注意： 闭包存在于嵌套的内部函数之中</li></ul><h4 id="11-1-3-产生闭包的条件"><a href="#11-1-3-产生闭包的条件" class="headerlink" title="11.1.3 产生闭包的条件"></a>11.1.3 产生闭包的条件</h4><ul><li>函数嵌套 </li><li>内部函数引用了外部函数的数据（变量&#x2F;函数）</li></ul><h4 id="11-2-1-常见的闭包"><a href="#11-2-1-常见的闭包" class="headerlink" title="11.2.1 常见的闭包"></a>11.2.1 常见的闭包</h4><ul><li>将函数作为另外一个函数的返回值</li><li>将函数作为实参残敌给另一个函数调用</li></ul><h4 id="11-3-1-闭包的作用"><a href="#11-3-1-闭包的作用" class="headerlink" title="11.3.1 闭包的作用"></a>11.3.1 闭包的作用</h4><ul><li>使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）</li><li>让函数外部可以操作（读写）到函数内部的数据（变量&#x2F;函数）</li></ul><h4 id="11-3-2-函数执行完成后，函数声明的局部变量是否存在？"><a href="#11-3-2-函数执行完成后，函数声明的局部变量是否存在？" class="headerlink" title="11.3.2 函数执行完成后，函数声明的局部变量是否存在？"></a>11.3.2 函数执行完成后，函数声明的局部变量是否存在？</h4><ul><li>一般不存在，存在于闭包中的变量才可能存在</li></ul><h4 id="11-3-3-（闭包）在函数外部能够直接访问函数内部的局部变量吗？"><a href="#11-3-3-（闭包）在函数外部能够直接访问函数内部的局部变量吗？" class="headerlink" title="11.3.3 （闭包）在函数外部能够直接访问函数内部的局部变量吗？"></a>11.3.3 （闭包）在函数外部能够直接访问函数内部的局部变量吗？</h4><ul><li>不能，但是我们可以通过闭包来让外部操作它</li></ul><h4 id="11-4-1-闭包的生命周期"><a href="#11-4-1-闭包的生命周期" class="headerlink" title="11.4.1 闭包的生命周期"></a>11.4.1 闭包的生命周期</h4><ul><li>产生：在嵌套函数定义执行完成时就已经产生了（不是在调用时才产生）</li><li>死亡：在嵌套的函数内部函数成为垃圾对象时</li></ul><h4 id="11-5-1-闭包的应用"><a href="#11-5-1-闭包的应用" class="headerlink" title="11.5.1 闭包的应用"></a>11.5.1 闭包的应用</h4><ul><li>定义JS模块：<ul><li>具有特定功能的JS文件</li><li>将所有数据和功能都封装在一个函数内部（私有）</li><li>只向外暴露一个包含n个方法的对象或函数</li><li>模块的使用者，只需要通过模块暴露的对象调用方法来实现相应的功能</li></ul></li></ul><h4 id="11-6-1-闭包的缺点"><a href="#11-6-1-闭包的缺点" class="headerlink" title="11.6.1 闭包的缺点"></a>11.6.1 闭包的缺点</h4><ul><li>缺点<ul><li>函数执行完成后，函数内的局部变量没有释放，占用内存的时间会变长</li><li>容易造成内存泄露</li></ul></li><li>解决方案<ul><li>能不用闭包就不用</li><li>及时释放</li></ul></li></ul><h2 id="12-对象"><a href="#12-对象" class="headerlink" title="12.对象"></a>12.对象</h2><h4 id="12-1-1-对象构造模式"><a href="#12-1-1-对象构造模式" class="headerlink" title="12.1.1 对象构造模式"></a>12.1.1 对象构造模式</h4><ul><li>Object构造函数模式：<ul><li>套路： 先创建空Object对象，再添加属性和方法</li><li>适用场景： 起始时不确定对象内部数据</li><li>问题： 语句太多</li></ul></li><li>对象字面量模式：<ul><li>套路： 使用{}创建对象，提示指定属性和方法</li><li>适用场景： 起始确定对象内部数据</li><li>问题： 如果创建多个对象，代码重复</li></ul></li><li>工厂模式：<ul><li>套路： 通过工厂函数（返回一个对象的函数）动态创建对象并返回</li><li>适用场景： 需要创建多个对象</li><li>问题： 没有一个具体的类型，都是Object类型</li></ul></li><li>自定义构造函数模式：<ul><li>套路： 通过自定义构造函数，通过new创建对象</li><li>适用场景： 需要创建多个类型确定的对象</li><li>问题： 每个对象都有相同的数据，代码冗余</li></ul></li><li>组合模式（构造函数+原型）：<ul><li>套路： 自定义构造函数，属性在函数中初始化，原型对象负责添加方法</li><li>适用场景： 需要创建多个类型确定的对象</li></ul></li></ul><h4 id="12-2-1-原型链继承"><a href="#12-2-1-原型链继承" class="headerlink" title="12.2.1 原型链继承"></a>12.2.1 原型链继承</h4><ul><li>套路：<ul><li>定义父类型构造函数</li><li>给父类型的原型添加方法</li><li>定义子类型构造函数</li><li>子类型构造函数的原型指向父类型构造函数的实例</li><li>将子类型的原型的构造属性设置为子类型</li><li>给子类型原型添加方法</li><li>创建子类型的对象</li></ul></li><li>关键：<ul><li>子类型构造函数的原型指向父类型构造函数的实例</li></ul></li></ul><h4 id="12-2-2-借用构造函数继承"><a href="#12-2-2-借用构造函数继承" class="headerlink" title="12.2.2 借用构造函数继承"></a>12.2.2 借用构造函数继承</h4><ul><li>套路：<ul><li>定义父类型构造函数</li><li>定义子类型构造函数</li><li>在子类型构造函数中调用父类型构造函数</li></ul></li><li>关键：<ul><li>子类型构造函数中通用super（）调用父类型构造函数</li></ul></li></ul><h4 id="12-2-3-组合继承"><a href="#12-2-3-组合继承" class="headerlink" title="12.2.3 组合继承"></a>12.2.3 组合继承</h4><ul><li>原型链+借用构造函数：<ul><li>利用原型链实现对父类型对象的方法继承</li><li>利用super（）调用父类型构造函数初始化相同属性</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/18/hello-world/"/>
    <url>/2024/09/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><!-- <img src="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="" title="[图片引用方法一]"> --><p><img src="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" alt="图片引用方法二"></p><p><img src="/images/test.png" alt="图片引用方法三"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
